<!DOCTYPE html>
<html lang="en">
    <!-- 
         Run server with (from the Alert2 repo):
              JTESTDIR=/home/redstone/home-monitoring/homeassistant JTEST_JS_DIR=/home/redstone/tmp/hass-alert2-ui venv/bin/pytest tests/dummy_server.py
         View page at:
             http://localhost:50005/jtest/tests/t2.html
         
    -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
         html {
             --primary-text-color: #212121;
             --secondary-text-color: #727272;
             --text-primary-color: #ffffff;
             --text-light-primary-color: #212121;
             --disabled-text-color: #bdbdbd;
             --primary-color: #03a9f4;
             --dark-primary-color: #0288d1;
             --light-primary-color: #b3e5fc;
             --accent-color: #ff9800;
             --divider-color: rgba(0, 0, 0, 0.12);
             --outline-color: rgba(0, 0, 0, 0.12);
             --outline-hover-color: rgba(0, 0, 0, 0.24);
             --scrollbar-thumb-color: rgb(194, 194, 194);
             --error-color: #db4437;
             --warning-color: #ffa600;
             --success-color: #43a047;
             --info-color: #039be5;
             --card-background-color: #ffffff;
             --primary-background-color: #fafafa;
             --secondary-background-color: #e5e5e5;
             --clear-background-color: #ffffff;

             --paper-font-body1_-_font-family: var(--paper-font-common-base_-_font-family);
             --paper-font-body1_-_-webkit-font-smoothing: var(--paper-font-common-base_-_-webkit-font-smoothing);
             --paper-font-body1_-_font-size: 14px;
             --paper-font-body1_-_font-weight: 400;
             --paper-font-body1_-_line-height: 20px;
             --paper-font-common-base_-_font-family: Roboto, Noto, sans-serif;
             --paper-font-common-base_-_-webkit-font-smoothing: antialiased;
             --paper-font-common-code_-_font-family: 'Roboto Mono', Consolas, Menlo, monospace;
             --paper-font-common-code_-_-webkit-font-smoothing: antialiased;
             --paper-font-common-expensive-kerning_-_text-rendering: optimizeLegibility;
             --paper-font-common-nowrap_-_white-space: nowrap;
             --paper-font-common-nowrap_-_overflow: hidden;
             --paper-font-common-nowrap_-_text-overflow: ellipsis;         
             --mdc-theme-primary: var(--primary-color);
             --mdc-theme-secondary: var(--accent-color);
             --mdc-theme-background: var(--primary-background-color);
             --mdc-theme-surface: var(--card-background-color);
             --mdc-theme-on-primary: var(--text-primary-color);
             --mdc-theme-on-secondary: var(--text-primary-color);
             --mdc-theme-on-surface: var(--primary-text-color);
             --mdc-theme-text-disabled-on-light: var(--disabled-text-color);
             --mdc-theme-text-primary-on-background: var(--primary-text-color);
             --mdc-theme-text-secondary-on-background: var(--secondary-text-color);
             --mdc-theme-text-hint-on-background: var(--secondary-text-color);
             --mdc-theme-text-icon-on-background: var(--secondary-text-color);
             --mdc-theme-error: var(--error-color);
         }
         ha-progress-button {
             
         }
        </style>
        <script>
         function waitForEvent(element, eventName) {
             return new Promise((resolve) => {
                 element.addEventListener(eventName, (event) => {
                     resolve(event);
                 });
             });
         }
         async function loadScript(src, ttype) {
             var script = document.createElement('script');
             script.src = src;
             if (ttype) {
                 script.type = ttype;
             }
             script.id = "jalid";
             document.head.appendChild(script);
             await waitForEvent(script, 'load');
         }
         //let createRowElementHass = null;
         window.loadCardHelpers = async function() {
             return { createRowElement: function(cfg) {
                 var er = document.createElement('hui-alert2-entity-row');
                 er.setConfig(cfg);
                 return er;
             }};
         }
         let testDiv;
         window.addEventListener('DOMContentLoaded', async function() {
             await loadScript('./ha-lib.js', 'module');
             await loadScript('../alert2.js');
             testDiv = document.querySelector('#testDiv');
             let alert2Tools = customElements.get('alert2-tools');
             alert2Tools.debounceMs = 1;
             if (0) {
                 jassert(await startTest(doTestConfig));
                 return;
             }
             jassert(await startTest(doTestDefaults));
             jassert(await startTest(doTestRender));
             jassert(await startTest(doTestCreate));
             jassert(await startTest(doTest4));
             jassert(await startTest(doTest5));
             jassert(await startTest(doTest6));
             jassert(await startTest(doTest7));
             jassert(await startTest(doTest8));
             jassert(await startTest(doTest9));
             jassert(await startTest(doTest10));
             jassert(await startTest(doTestConfig));
             let testStatusEl = document.querySelector('#testStatus');
             if (jassertFailCount == 0) {
                 testStatusEl.innerHTML = `Test: All done`;
             } else {
                 testStatusEl.innerHTML = `Test: Ended with errors`;
             }
         });
         // jassert and jassertFailCount are declared in alert2.js
         function jasserteq(a, b) {
             if (a !== b) {
                 jassertFailCount += 1;
                 throw new Error(`assert failed "${a}" != "${b}"`);
                 
             }
         }
         function testObjeq(obj1, obj2) {
             if (obj1 === obj2) return true;
             if (typeof obj1 !== 'object' || obj1 === null || 
                 typeof obj2 !== 'object' || obj2 === null) {
                 return false;
             }
             if ((obj1 instanceof Set) !== (obj2 instanceof Set)) { return false; }
             if (obj1 instanceof Set) {
                 if (obj1.size !== obj2.size) { return false; }
                 return obj1.intersection(obj2).size === obj1.size;
             }
             const keys1 = Object.keys(obj1);
             const keys2 = Object.keys(obj2);
             if (keys1.length !== keys2.length) return false;
             for (const key of keys1) {
                 if (!keys2.includes(key) || !testObjeq(obj1[key], obj2[key])) {
                     return false;
                 }
             }
             return true;
         }
         function jassertObjeq(a, b) {
             if (!testObjeq(a, b)) {
                 console.error(a, '  !=  ', b);
                 jassert(false);
             }
         }
         function sleepMs(ms) {
             return new Promise(resolve => setTimeout(resolve, ms));
         }
         function getRecentIso(msAgo) {
             return (new Date((new Date()).getTime() - msAgo)).toISOString();
         }
         function cloneHass(ahass) {
                 return {
                     states: Object.assign({}, ahass['states'])
                 };
         }
         function createState(name, onAgoMs, offAgoMs, ackAgoMs=200) {
             return { state: (offAgoMs < onAgoMs) ? 'off':'on',
                      attributes: { 'last_on_time': getRecentIso(onAgoMs),
                                    'last_off_time': getRecentIso(offAgoMs),
                                    'notification_control': NOTIFICATIONS_ENABLED,
                                    'last_ack_time': getRecentIso(ackAgoMs),
                                    'fires_since_last_notify': 0,
                                    domain: 'd',
                                    name: name,
                      },
                      entity_id: 'alert2.d_'+name };
         }
         async function createExperiment(z, stateList, nodeList, nBelow=0) {
             let hass = { states: {
                 'binary_sensor.alert2_ha_startup_done': { state: 'on', attributes: { manifest_version: 'v.a.b.c' } },
             },
                          callApi: z.firstHass.callApi,
                          callWs: z.firstHass.callWs,
                          connection: z.firstHass.connection
             };
             for (const astate of stateList) {
                 hass.states['alert2.'+astate.attributes.domain+'_'+astate.attributes.name] = astate;
             }
             console.log('createExperiment with', hass);
             z.ao.hass = hass;
             await sleepMs(1200);
             let tEls = z.ao.shadowRoot.querySelectorAll('hui-alert2-entity-row');
             jasserteq(tEls.length, nodeList.length);
             for (let idx = 0 ; idx < nodeList.length ; idx++) {
                 jassert(tEls[idx].shadowRoot.innerHTML.includes(nodeList[idx]));
             }
             tEls = z.ao.shadowRoot.querySelectorAll('div#ackbar ~ hui-alert2-entity-row');
             jasserteq(tEls.length, nBelow);
         }
         function createEventState(name, fireAgoMs, ackAgoMs=200) {
             return { state: getRecentIso(fireAgoMs),
                      attributes: { 'notification_control': NOTIFICATIONS_ENABLED,
                                    'last_ack_time': getRecentIso(ackAgoMs),
                                    'fires_since_last_notify': 0 },
                      entity_id: 'alert2.'+name };
         }
         async function callApi(type, method, opts) {
             const settings = {
                 method: type,
                 headers: {
                     Accept: 'application/json',
                     'Content-Type': 'application/json',
                 },
                 body: JSON.stringify(opts),
             };
             let fetchResponse;
             let data;
             try {
                 fetchResponse = await fetch(`http://localhost:50005/api/${method}`, settings);
                 data = await fetchResponse.json();
             } catch (e) {
                 console.error(method, opts, e);
                 throw e;
             }
             console.log('got response to', method, opts, '   as   ', data, 'ok=',fetchResponse.ok);
             if (!fetchResponse.ok) {
                 throw {
                     error: `Response error: ${fetchResponse.status} with msg=${data.message}`,
                     status_code: fetchResponse.status,
                     message: data.message,
                     body: data
                 };
             }
             return data;
         }
         async function initTest(eName, extraParams, config=null) {
             let evCbMap = {};
             let rezCbMap = {};
             let ws = new WebSocket('http://localhost:50005/api/websocket');
             ws.addEventListener('close', function(ev) {             console.log('ws got close', ev); });
             ws.addEventListener('error', function(ev) {             console.log('ws got error', ev); });
             let done = new Promise( (resolve) => {
                 const handle_msg = function(ev) {
                     const msg = JSON.parse(ev.data);
                     console.log('ws got message', msg);
                     if (msg.type == 'auth_ok') {
                         ws.removeEventListener('message', handle_msg);
                         resolve();
                     }
                 };
                 ws.addEventListener('message', handle_msg);
                 ws.addEventListener('open', function(ev) {
                     console.log('ws got open', ev);
                     ws.send(JSON.stringify({ type: 'auth', access_token: 'foobar'}));
                 });
             });
             await done;
             let msgId = 1;
             let hmsg = function(ev) {
                 const msg = JSON.parse(ev.data);
                 console.log('got ws message inside subscribe: ', msg);
                 if (msg.type == 'result') {
                     jasserteq(msg.success, true);
                 }
                 if (evCbMap['z'+msg.id]) {
                     jassert(msg.type == 'event' || msg.type == 'result');
                     if (msg.type == 'event') {
                         jasserteq(msg.type, 'event');
                         evCbMap['z'+msg.id](msg.event);
                     }
                 }
                 if (rezCbMap['z'+msg.id]) {
                     jasserteq(msg.type, 'result');
                     rezCbMap['z'+msg.id](msg.result);
                 }
             }
             ws.addEventListener('message', hmsg);

             let connection = {
                 sendMessagePromise: async function (mdata) {
                     msgId += 1;
                     let myId = msgId;
                     mdata.id = myId;
                     console.log(`ah, got call to sendMessagePromise. new id=${myId}. mdata=`, mdata);
                     let rez = await (new Promise((resolve)=>{
                         rezCbMap['z'+myId] = function (ev) {
                             delete rezCbMap['z'+myId];
                             resolve(ev);
                         }
                         ws.send(JSON.stringify(mdata));
                     }));
                     return rez;
                 },
                 subscribeMessage: function (cb, mdata) {
                     msgId += 1;
                     let myId = msgId;
                     console.log(`ah, got call to subscribeMessage. new id=${myId}. mdata=`, mdata);
                     evCbMap['z'+myId] = cb;
                     let subDonePromise = new Promise((resolve)=>{
                         resolve( ()=>{
                             msgId += 1;
                             let myId2 = msgId;
                             console.log(`Got unsubscribe to id=${myId}. Sending unsub with id=${myId2}`);
                             jassert(evCbMap['z'+myId]);
                             delete evCbMap['z'+myId];
                             ws.send(JSON.stringify({ type: 'unsubscribe_events', subscription: myId, id: myId2 }));
                         } );
                     });
                     mdata.id = myId;
                     jassert(mdata.type == 'alert2_watch_display_msg' || mdata.type == 'alert2_watch_display_config');
                     ws.send(JSON.stringify(mdata));
                     return subDonePromise;
                 }
             };
             let callWs = async function(params) {
                 msgId += 1;
                 let myId = msgId;
                 jasserteq(params.type, 'execute_script');
                 params.id = myId;
                 ws.send(JSON.stringify(params));
             }
             let newHass = {
                 states: { 'binary_sensor.alert2_ha_startup_done' : { attributes: { manifest_version: 'v.a.b.c' } } },
                 callApi: callApi,
                 callWs: callWs,
                 connection: connection,
             };

             
             //ws.close();
             
             let ao = document.createElement(eName);
             //console.log('ao is ', ao, eName);
             ao.hass = newHass;
             if (extraParams) {
                 Object.assign(ao, extraParams);
             }
             if (config) {
                 ao.setConfig(config);
             }
             if (eName == 'alert2-create') {
                 ao.didSomethingCb = ()=>{
                     //console.log('alert2-create didSomethingCb');
                 };
             }
             testDiv.appendChild(ao);
             let z = {ao: ao, ws: ws, firstHass: newHass, callWs: callWs };
             if (['alert2-create','alert2-edit-defaults'].includes(eName)) {
                 let c = 0;
                 while (true) {
                     await sleepMs(10);
                     //if (ao.innerHTML) { break; }
                     let tt = ao.shadowRoot.querySelector(`alert2-cfg-field[name="notifier"]`);
                     if (tt) { break; }
                     //console.log('no ao :(...', !!tt);
                     jassert(c < 50);
                     c++;
                 }
                 Object.assign(z, createHelpers(ao));
             }
             return z;
         }
         async function startTest(afunc) {
             let testStatusEl = document.querySelector('#testStatus');

             let tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset'} );
             if (!testObjeq(tobj, {})) {
                 testStatusEl.innerHTML = `Test: Server data not empty. Needs restart`;
                 return false;
             }
             testStatusEl.innerHTML = `Test: Running ${afunc.name}...`;
             await afunc();
             //ao.remove();
             testStatusEl.innerHTML = `Test: Done ${afunc.name}`;
             return true;
         }
         async function waitDone(abutton) {
             await sleepMs(10);
             while (true) {
                 if (!abutton.progress) { return; }
                 await sleepMs(50);
             }
         }
         async function clickWait(abutton) {
             jassert(abutton);
             abutton.click();
             await waitDone(abutton);
         }
         function createHelpers(ao) {
             function checkField(aname, val) {
                 let currP = ao.shadowRoot.querySelector(`alert2-cfg-field[name="${aname}"]`).currP;
                 //console.log('checkField', aname, JSON.stringify(currP));
                 jassert(currP);
                 if (val === null) {
                     jassert(!Object.hasOwn(currP, aname));
                 } else {
                     jasserteq(currP[aname], val);
                 }
             }
             async function checkRender(aname, aregex) {
                 let cf = ao.shadowRoot.querySelector(`alert2-cfg-field[name="${aname}"]`);
                 await sleepMs(3);
                 //console.log(aname, cf.shadowRoot.innerHTML);
                 while (true) {
                     await sleepMs(20);
                     let jj = cf.shadowRoot.querySelector('ha-circular-progress');
                     if (!jj) { break; }
                 }
                 await sleepMs(3);
                 let ri = cf.shadowRoot.querySelector('div.renderInfo');
                 jassert(ri);
                 let inner = ri.innerHTML;
                 jassert(inner);
                 let txt = ri.textContent;
                 let idx = txt.search(aregex);
                 //console.log('Render to be tested is:', inner, aregex, idx);
                 //console.log('Render3 to be tested is:', ri.textContent);
                 if (! (idx >= 0)) {
                     console.log(`Did not find "${aregex}" in ${txt}`);
                     jassert(false);
                 }
                 //if (!aregex.source.includes('alert') && inner.includes('alert')) {
                 //    console.log(`Unexpected alert found in ${inner}`);
                 //    jassert(false);
                 // }
             }
             async function setField(aname, val) {
                 jasserteq(typeof val, "string");
                 let cf = ao.shadowRoot.querySelector(`alert2-cfg-field[name="${aname}"]`);
                 let jj = cf.shadowRoot.querySelector('ha-textfield');
                 if (jj) {
                     if (val == '') {
                         jj.value = val;
                     }
                     jFireEvent(jj, 'input', { value: val });
                     //jj.value = val;
                 } else {
                     if (val == '') {
                         //jassert(false);
                         let cc = 100;
                         if (0) {
                             jj = cf.shadowRoot.querySelector('ha-code-editor')
                                    .shadowRoot.querySelector('ha-textfield')
                                    .shadowRoot.querySelector('input');
                             jassert(jj);
                             jj.focus();
                             await sleepMs(1);
                         } else {
                         }
                         jj = cf.shadowRoot.querySelector('ha-code-editor');
                         jassert(jj);
                         jj.value = val;
                         jFireEvent(jj, 'value-changed', { value: val });
                         while (cc-- > 0) {
                             await sleepMs(1);
                             //jFireEvent(jj, 'input', { value: val });
                             //jFireEvent(jj, 'change', { value: val });
                             await sleepMs(1);
                             if (jj.value == val &&
                                 !Object.hasOwn(cf.currP, aname)) {
                                 break;
                             }
                             await sleepMs(10);
                             console.log('    waiting for val to become empty', jj.value, val, cf.currP[aname]);
                         }
                     } else {
                         jj = cf.shadowRoot.querySelector('ha-code-editor');
                         jassert(jj);
                         jFireEvent(jj, 'value-changed', { value: val });
                     }
                 }
                 await sleepMs(5);
                 let hasSub = ['value','hysteresis','maximum','minimum'].includes(aname);
                 
                 console.log(`setting ${aname} to "${val}" and data=${cf.currP[aname]}`);
                 if (val == '') {
                     if (hasSub) {
                         jassert(!Object.hasOwn(cf.currP, 'threshold') || !Object.hasOwn(cf.currP['threshold'], aname));
                     } else {
                         jassert(!Object.hasOwn(cf.currP, aname));
                     }
                 } else {
                     if (hasSub) {
                         jasserteq(cf.currP['threshold'][aname], val);
                     } else {
                         jasserteq(cf.currP[aname], val);
                     }
                 }
             }
             function checkErr(aregex) {
                 let errD = ao.shadowRoot.querySelector('ha-alert');
                 if (!aregex) {
                     jassert(!errD);
                 } else {
                     let txt = errD.textContent;
                     let idx = txt.search(aregex);
                     if (! (idx >= 0)) {
                         console.log(`Did not find "${aregex}" in ${txt}`);
                         jassert(false);
                     }
                 }
             }
             function checkDefault(aname, aregex) {
                 let cf = ao.shadowRoot.querySelector(`alert2-cfg-field[name="${aname}"]`);
                 let pp = cf.shadowRoot.querySelector(`div.defaultInfo`);
                 if (aregex === null) {
                     jassert(!pp);
                 } else {
                     let txt = pp.textContent;
                     let idx = txt.search(aregex);
                     if (! (idx >= 0)) {
                         console.log(`Did not find "${aregex}" in ${txt}`);
                         jassert(false);
                     }
                 }
             }
             return {
                 checkField: checkField,
                 checkRender: checkRender,
                 setField: setField,
                 checkErr: checkErr,
                 checkDefault: checkDefault,
             };
         }
         async function doTestDefaults() {
             let z = await initTest('alert2-edit-defaults');
             await sleepMs(10); // seems to help dom get itself sorted out
                     
             // We start with an empty defaults page
             //
             z.checkField('notifier', null);
             z.checkField('summary_notifier', null);
             z.checkField('annotate_messages', null);
             z.checkField('reminder_frequency_mins', null);
             z.checkField('throttle_fires_per_mins', null);
             z.checkField('priority', null);
             z.checkField('skip_internal_errors', null);
             z.checkField('notifier_startup_grace_secs', null);
             z.checkField('defer_startup_notifications', null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {} }});
             // Save the empty page
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {} }});
             // Change a field
             await z.setField('notifier', 'foo');
             await z.checkRender('notifier', /len=1.*"foo"/);
             await z.setField('notifier', '');
             await z.checkRender('notifier', /^\s+$/);
             await z.setField('notifier', 'foo,bar');
             await z.checkRender('notifier', /illegal characters/);
             await z.setField('notifier', '[foo,bar]');
             await z.checkRender('notifier', /len=2.*"foo","bar"/);
             await z.setField('notifier', '{{ ["foo","baz"   ] }}');
             await z.checkRender('notifier', /len=2.*"foo","baz"/);
             await z.setField('notifier', 'foo');
             await z.checkRender('notifier', /len=1.*"foo"/);

             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: { notifier: 'foo' } }});

             // Reload dialog and check foo is there.
             z.ao.remove();
             await sleepMs(11);
             z = await initTest('alert2-edit-defaults');
             await sleepMs(100);
             z.checkField('notifier', 'foo');
             // Now remove foo 
             await z.setField('notifier', '');
             await z.checkRender('notifier', /^\s+$/);
             z.checkField('notifier', null);
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: { } }});

             // summary_notifier
             await z.setField('summary_notifier', 'sfoo');
             await z.checkRender('summary_notifier', /len=1.*"sfoo"/);
             await z.setField('summary_notifier', '["sfoo","ss"]');
             await z.checkRender('summary_notifier', /len=2.*"sfoo","ss"/);
             await z.setField('summary_notifier', '');
             await z.checkRender('summary_notifier', /^\s+$/);

             // annotate_messages
             await z.setField('annotate_messages', 'on');
             await z.checkRender('annotate_messages', /result:true/);
             await z.setField('annotate_messages', 'foo');
             await z.checkRender('annotate_messages', /invalid boolean/);
             await z.setField('annotate_messages', 'off');
             await z.checkRender('annotate_messages', /result:false/);
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: { 'annotate_messages': 'off' } }});
             await z.setField('annotate_messages', '');
             await sleepMs(150);
             await z.checkRender('annotate_messages', /^\s+$/);

             // reminder_frequency_mins
             await z.setField('reminder_frequency_mins', '3');
             await z.checkRender('reminder_frequency_mins', /len=1\):\[3\]/);
             await z.setField('reminder_frequency_mins', '3,4');
             await z.checkRender('reminder_frequency_mins', /expected float/);
             await z.setField('reminder_frequency_mins', '[3,4]');
             await z.checkRender('reminder_frequency_mins', /len=2\):\[3,4\]/);

             // throttle_fires_per_mins
             await z.setField('throttle_fires_per_mins', '3');
             await z.checkRender('throttle_fires_per_mins', /not a valid value/);
             await z.setField('throttle_fires_per_mins', '[3,5]');
             await z.checkRender('throttle_fires_per_mins', /len=2\):\[3,5\]/);
             
             // priority
             await z.setField('priority', '3');
             await z.checkRender('priority', /must be one of/);
             await z.setField('priority', 'low');
             await z.checkRender('priority', /"low"/);

             await z.setField('skip_internal_errors', 'foo');
             await z.checkRender('skip_internal_errors', /invalid boolean/);
             await z.setField('skip_internal_errors', 'on');
             await z.checkRender('skip_internal_errors', /result:true/);

             await z.setField('notifier_startup_grace_secs', '-3');
             await z.checkRender('notifier_startup_grace_secs', /must be at least 0.0/);
             await z.setField('notifier_startup_grace_secs', '3');
             await z.checkRender('notifier_startup_grace_secs', /result:3/);

             await z.setField('defer_startup_notifications', 'yes');
             await z.checkRender('defer_startup_notifications', /result:true/);
             await z.setField('defer_startup_notifications', '[foo, zz ]');
             await z.checkRender('defer_startup_notifications', /len=2\):\["foo","zz"\]/);

             // Try setting all
             z.setField('notifier', '[nfoo,  nnfoo]');
             z.setField('summary_notifier', 'snfoo');
             z.setField('annotate_messages', 'yes');
             z.setField('reminder_frequency_mins', '77');
             z.setField('throttle_fires_per_mins', '[2,5]');
             z.setField('skip_internal_errors', 'no');
             z.setField('notifier_startup_grace_secs', '6.2');
             z.setField('defer_startup_notifications', '[blah,ick]');
             z.setField('priority', 'medium');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {
                              notifier: '[nfoo,  nnfoo]',
                              summary_notifier: 'snfoo',
                              annotate_messages: 'yes',
                              reminder_frequency_mins: '77',
                              throttle_fires_per_mins: '[2,5]',
                              priority: 'medium',
                          },
                                    skip_internal_errors: 'no',
                                    notifier_startup_grace_secs: '6.2',
                                    defer_startup_notifications: '[blah,ick]'
                          }})

             // Update two and remove two
             z.setField('notifier', '[nfoo,  nnfoo3]');
             z.setField('summary_notifier', '');
             z.setField('notifier_startup_grace_secs', '6.3');
             z.setField('defer_startup_notifications', '');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {
                              notifier: '[nfoo,  nnfoo3]',
                              annotate_messages: 'yes',
                              reminder_frequency_mins: '77',
                              throttle_fires_per_mins: '[2,5]',
                              priority: 'medium',
                          },
                                    skip_internal_errors: 'no',
                                    notifier_startup_grace_secs: '6.3',
                          }})

             // Reload page to see if we get what we expect
             z.ao.remove();
             await sleepMs(11);
             z = await initTest('alert2-edit-defaults');
             await sleepMs(11);
             z.checkField('notifier', '[nfoo,  nnfoo3]');
             z.checkField('summary_notifier', null);
             z.checkField('annotate_messages', 'yes');
             z.checkField('reminder_frequency_mins', '77');
             z.checkField('throttle_fires_per_mins', '[2,5]');
             z.checkField('priority', 'medium');
             
             z.checkField('skip_internal_errors', 'no');
             z.checkField('notifier_startup_grace_secs', '6.3');
             z.checkField('defer_startup_notifications', null);
             z.ao.remove();
         }
         async function doTestRender() {
             // Create new alert
             let z = await initTest('alert2-create');
             await sleepMs(10); // seems to help dom get itself sorted out

             // domain
             await z.setField('domain', '');
             await z.checkField('domain', null);
             await z.setField('domain', 'a');
             await z.checkRender('domain', /result:"a"/);
             await z.setField('domain', 'a{{"b"');
             await z.checkRender('domain', /invalid template/);
             await z.setField('domain', 'a{{"b"}}');
             await z.checkRender('domain', /result:"ab"/);
             await z.setField('domain', 'd');
             
             // name
             await z.setField('name', '');
             await z.checkField('name', null);
             await z.setField('name', 'a');
             await z.checkRender('name', /result:"a"/);
             await z.setField('name', 'a{{"b"}}');
             await z.checkRender('name', /result:"ab"/);
             await z.setField('name', 'n');

             // friendly_name
             await z.setField('friendly_name', '');
             await z.checkField('friendly_name', null);
             await z.setField('friendly_name', 'a');
             await z.checkRender('friendly_name', /result:"a"/);
             await z.setField('friendly_name', 'a{{"b"}}');
             await z.checkRender('friendly_name', /result:"ab"/);
             await z.setField('friendly_name', 'f');

             // condition
             await z.setField('condition', '');
             await z.checkField('condition', null);
             await z.setField('condition', 'on');
             await z.checkRender('condition', /result:true/);
             await z.setField('condition', '{{"yes"}}');
             await z.checkRender('condition', /result:true/);
             await z.setField('condition', 'off');

             // condition_on
             await z.setField('condition_on', '');
             await z.checkField('condition_on', null);
             await z.setField('condition_on', 'on');
             await z.checkRender('condition_on', /result:true/);
             await z.setField('condition_on', '{{"yes"}}');
             await z.checkRender('condition_on', /result:true/);
             await z.setField('condition_on', 'off');

             // condition_off
             await z.setField('condition_off', '');
             await z.checkField('condition_off', null);
             await z.setField('condition_off', 'on');
             await z.checkRender('condition_off', /result:true/);
             await z.setField('condition_off', '{{"yes"}}');
             await z.checkRender('condition_off', /result:true/);
             await z.setField('condition_off', 'off');

             // trigger
             await z.setField('trigger', '');
             await z.checkField('trigger', null);
             await z.setField('trigger', 'on');
             await z.checkRender('trigger', /is not iterable/);
             await z.setField('trigger', "[{'platform':'state','entity_id':'sensor.zz'}]");
             await z.checkRender('trigger', /\[{"platform":"state/);
             await z.setField('trigger', '');
             await z.checkField('trigger', null);

             // trigger_on
             await z.setField('trigger_on', '');
             await z.checkField('trigger_on', null);
             await z.setField('trigger_on', 'on');
             await z.checkRender('trigger_on', /is not iterable/);
             await z.setField('trigger_on', "[{'platform':'state','entity_id':'sensor.zz'}]");
             await z.checkRender('trigger_on', /\[{"platform":"state/);
             await z.setField('trigger_on', '');
             await z.checkField('trigger_on', null);

             // trigger_off
             await z.setField('trigger_off', '');
             await z.checkField('trigger_off', null);
             await z.setField('trigger_off', 'on');
             await z.checkRender('trigger_off', /is not iterable/);
             await z.setField('trigger_off', "[{'platform':'state','entity_id':'sensor.zz'}]");
             await z.checkRender('trigger_off', /\[{"platform":"state/);
             await z.setField('trigger_off', '');
             await z.checkField('trigger_off', null);

             // threshold: value
             await z.setField('value', '3');
             await z.checkRender('value', /result:3/);
             await z.setField('value', '');
             await z.checkField('value', null);
             
             // threshold: hysteresis
             await z.setField('hysteresis', '3');
             await z.checkRender('hysteresis', /result:3/);
             await z.setField('hysteresis', '-3');
             await z.checkRender('hysteresis', /value must be at least/);
             await z.setField('hysteresis', '');
             await z.checkField('hysteresis', null);
             
             // threshold: minimum
             await z.setField('minimum', '3');
             await z.checkRender('minimum', /result:3/);
             await z.setField('minimum', '');
             await z.checkField('minimum', null);
             
             // threshold: maximum
             await z.setField('maximum', '3');
             await z.checkRender('maximum', /result:3/);
             await z.setField('maximum', '');
             await z.checkField('maximum', null);

             // delay_on_secs
             await z.setField('delay_on_secs', '3');
             await z.checkRender('delay_on_secs', /result:3/);
             await z.setField('delay_on_secs', 'a');
             await z.checkRender('delay_on_secs', /expected float/);
             await z.setField('delay_on_secs', '');
             await z.checkField('delay_on_secs', null);

             // early_start
             await z.setField('early_start', 'off');
             await z.checkRender('early_start', /result:false/);
             await z.setField('early_start', '');
             await z.checkField('early_start', null);

             // manual_on
             await z.setField('manual_on', 'off');
             await z.checkRender('manual_on', /result:false/);
             await z.setField('manual_on', '');
             await z.checkField('manual_on', null);

             // manual_off
             await z.setField('manual_off', 'off');
             await z.checkRender('manual_off', /result:false/);
             await z.setField('manual_off', '');
             await z.checkField('manual_off', null);

             // message
             await z.setField('message', 'yay');
             await z.checkRender('message', /result:"yay"/);
             await z.setField('message', '{{"a"+"b"}}');
             await z.checkRender('message', /result:"ab"/);
             await z.setField('message', '');
             await z.checkField('message', null);

             // done_message
             await z.setField('done_message', 'yay');
             await z.checkRender('done_message', /result:"yay"/);
             await z.setField('done_message', '{{"a"+"b"}}');
             await z.checkRender('done_message', /result:"ab"/);
             await z.setField('done_message', '');
             await z.checkField('done_message', null);

             // notifier
             await z.setField('notifier', 'yay');
             await z.checkRender('notifier', /result \(len=1\):\["yay"\]/);
             await z.setField('notifier', '{{"a"+"b"}}');
             await z.checkRender('notifier', /result \(len=1\):\["ab"\]/);
             await z.setField('notifier', '[a,b]');
             await z.checkRender('notifier', /result \(len=2\):\["a","b"\]/);
             await z.setField('notifier', '');
             await z.checkField('notifier', null);
             await z.setField('notifier', 'null');
             await z.checkRender('notifier', /result \(len=0\):\[\]/);

             // summary_notifier
             await z.setField('summary_notifier', 'yay');
             await z.checkRender('summary_notifier', /result \(len=1\):\["yay"\]/);
             await z.setField('summary_notifier', '{{"a"+"b"}}');
             await z.checkRender('summary_notifier', /result \(len=1\):\["ab"\]/);
             await z.setField('summary_notifier', '[a,b]');
             await z.checkRender('summary_notifier', /result \(len=2\):\["a","b"\]/);
             await z.setField('summary_notifier', '');
             await z.checkField('summary_notifier', null);

             // title
             await z.setField('title', 'yay');
             await z.checkRender('title', /result:"yay"/);
             await z.setField('title', '{{"a"+"b"}}');
             await z.checkRender('title', /result:"ab"/);
             await z.setField('title', '');
             await z.checkField('title', null);

             // display_msg
             await z.setField('display_msg', 'yay');
             await z.checkRender('display_msg', /result:"yay"/);
             await z.setField('display_msg', '{{"a"+"b"}}');
             await z.checkRender('display_msg', /result:"ab"/);
             await z.setField('display_msg', '');
             await z.checkField('display_msg', null);
             await z.setField('display_msg', 'null');
             await z.checkRender('display_msg', /result:null/);

             // target
             await z.setField('target', 'yay');
             await z.checkRender('target', /result:"yay"/);
             await z.setField('target', '{{"a"+"b"}}');
             await z.checkRender('target', /result:"ab"/);
             await z.setField('target', '');
             await z.checkField('target', null);

             // data
             await z.setField('data', 'yay');
             await z.checkRender('data', /expected dict/);
             await z.setField('data', '{a: 3}');
             await z.checkRender('data', /result:{"a":3}/);
             await z.setField('data', '{a: 3, "b": foo, "c": 3}');
             await z.checkRender('data', /result:{"a":3,"b":"foo","c":3}/);
             await z.setField('data', '');
             await z.checkField('data', null);

             // throttle_fires_per_mins
             await z.setField('throttle_fires_per_mins', '3,4');
             await z.checkRender('throttle_fires_per_mins', /not a valid/);
             await z.setField('throttle_fires_per_mins', '[3,4]');
             await z.checkRender('throttle_fires_per_mins', /result \(len=2\):\[3,4\]/);
             await z.setField('throttle_fires_per_mins', '');
             await z.checkField('throttle_fires_per_mins', null);

             // reminder_frequency_mins
             await z.setField('reminder_frequency_mins', '3');
             await z.checkRender('reminder_frequency_mins', /result \(len=1\):\[3\]/);
             await z.setField('reminder_frequency_mins', '[3,4]');
             await z.checkRender('reminder_frequency_mins', /result \(len=2\):\[3,4\]/);
             await z.setField('reminder_frequency_mins', '');
             await z.checkField('reminder_frequency_mins', null);

             // priority
             await z.setField('priority', 'high');
             await z.checkRender('priority', /result:"high"/);
             await z.setField('priority', '');
             await z.checkField('priority', null);
             
             // supersedes
             await z.setField('supersedes', '{ "domain":"d","name":"n" }');
             await z.checkRender('supersedes', /result \(len=1\):\[{"domain":"d","name":"n"}\]/);
             await z.setField('supersedes', '{domain: d, name: n3}');
             await z.checkRender('supersedes', /result \(len=1\):\[{"domain":"d","name":"n3"}\]/);
             await z.setField('supersedes', '[{ "domain":"d","name":"n" },{ "domain":"d","name":"n2" }]');
             await z.checkRender('supersedes', /result \(len=2\):\[{"domain":"d","name":"n"},{"domain":"d","name":"n2"}\]/);
             await z.setField('supersedes', '');
             await z.checkField('supersedes', null);
             await z.setField('supersedes', 'null');
             await z.checkRender('supersedes', /result:null/);

             // annotate_messages
             await z.setField('annotate_messages', 'off');
             await z.checkRender('annotate_messages', /result:false/);
             await z.setField('annotate_messages', '');
             await z.checkField('annotate_messages', null);

             // generator
             await z.setField('generator', 'ff');
             await z.checkRender('generator', /len=1\):\["ff"\].*\n.*First element vars/);
             await z.setField('generator', '[f1,f2]');
             await z.checkRender('generator', /len=2\):\["f1","f2"\].*\n.*First element vars/);
             await z.setField('generator', '');
             await z.checkField('generator', null);
             await z.setField('generator', '[20, 10');
             await z.checkRender('generator', /YAML parse error/);
             await z.setField('generator', '[20, 10]');
             await z.checkRender('generator', /len=2\):\[20,10\].*\n.*First element vars/);

             // generator_name
             await z.setField('generator_name', 'yay');
             await z.checkRender('generator_name', /result:"yay"/);
             await z.setField('generator_name', '');
             await z.checkField('generator_name', null);
             z.ao.remove();
         }
         async function doTestCreate() {
             // Create new alert
             let z = await initTest('alert2-create');
             await sleepMs(10); // seems to help dom get itself sorted out

             // Update with empty fields fails
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.updateB'));
             z.checkErr(/required key not provided/);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {} } })
             // Delete with empty fields fails
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.deleteB'));
             z.checkErr(/required key not provided/);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {} } })

             
             // Create fails - missing fields
             await z.setField('domain', 'd1');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(/required key.*domain/);

             // So does validate
             await z.setField('name', 'n1');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.validateB'));
             z.checkErr(/Must specify either/);
             
             // Complete fields, validate succeeds
             await z.setField('condition', 'off');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.validateB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}}})
             
             // So does create
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'off' }
                          ]}})

             // duplicate create should fail
             await z.setField('condition', 'on');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(/Duplicate declaration/);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'off' }
                          ]}})

             // Update
             await z.setField('condition', 'false');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.updateB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'false' }
                          ]}})

             // Update won't create
             await z.setField('condition', 'false');
             await z.setField('name', 'n2');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.updateB'));
             z.checkErr(/can not find existing/);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'false' }
                          ]}})
             await z.setField('name', 'n1');
             
             // Delete succeeds
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.deleteB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {} } })

             // Delete again should fail
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.deleteB'));
             z.checkErr(/can not find existing/);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {} } })

             // Let's check generator updating
             await z.setField('name', '{{genElem}}');
             await z.checkRender('name', /result:""/);
             await z.setField('generator', 'f2');
             await sleepMs(50); // extra sleep needed for some reason ;(
             await z.checkRender('name', /result:"f2"/);
             await z.setField('generator', '');
             await z.checkRender('name', /result:""/);

             // Create a generator
             await z.setField('generator', 'f3');
             await z.setField('generator_name', 'g1');
             await z.setField('name', '{{genElem}}');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: '{{genElem}}', condition: 'false', generator_name:'g1',
                              generator: 'f3' }
                          ]}})

             // Create a simple alert
             await z.setField('generator', '');
             await z.setField('generator_name', '');
             await z.setField('name', 'n2');
             await z.setField('delay_on_secs', '3');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: '{{genElem}}', condition: 'false', generator_name:'g1',
                              generator: 'f3' },
                              { domain: 'd1', name: 'n2', condition: 'false', delay_on_secs: '3' }
                          ]}})

             // Now let's reopen the create dialog as if editing existing alert
             z.ao.remove();
             z = await initTest('alert2-create', {entInfo: { domain: 'd1', name: 'n2' }});
             await sleepMs(50); // extra sleep needed for some reason ;(
             await z.checkField('domain', 'd1');
             await z.checkRender('domain', 'result:"d1"');
             await z.checkField('name', 'n2');
             await z.checkField('delay_on_secs', '3');

             // Try updating it
             await z.setField('delay_on_secs', '4');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.updateB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: '{{genElem}}', condition: 'false', generator_name:'g1',
                              generator: 'f3' },
                              { domain: 'd1', name: 'n2', condition: 'false', delay_on_secs: '4' }
                          ]}})

             // Now reopen dialog of generator alert
             z.ao.remove();
             z = await initTest('alert2-create', {entInfo: { domain: 'alert2generator', name: 'g1' }});
             await sleepMs(50); // extra sleep needed for some reason ;(
             await z.checkField('domain', 'd1');
             await z.checkField('name', '{{genElem}}');
             await z.checkRender('name', 'result:"f3"');
             await z.checkField('delay_on_secs', null);
             
             // Try updating it
             await z.setField('name', '{{genElem}}z');
             await z.checkRender('name', 'result:"f3z"');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.updateB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: '{{genElem}}z', condition: 'false', generator_name:'g1',
                              generator: 'f3' },
                              { domain: 'd1', name: 'n2', condition: 'false', delay_on_secs: '4' }
                          ]}})

             // Delete succeeds
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.deleteB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n2', condition: 'false', delay_on_secs: '4' }
                          ]}})
             
             z.ao.remove();
         }
         async function doTest4() {
             let z = await initTest('alert2-manager');
             await sleepMs(10); // seems to help dom get itself sorted out

             async function waitSearch() {
                 while (true) {
                     await sleepMs(10);
                     let s = z.ao.getSearchStatus();
                     if (s.inProgress === false) {
                         await sleepMs(3);
                         return s.rez;
                     }
                 }
             }
             
             // Check when there are no alerts in existence
             jasserteq((await waitSearch()).results.length, 0);
             let rs = z.ao.shadowRoot.querySelectorAll('div.results div');
             jasserteq(rs.length, 0);
             z.ao.remove();

             // Now create a few alerts
             z = await initTest('alert2-create');
             await sleepMs(10); // seems to help dom get itself sorted out
             await z.setField('domain', 'd1');
             await z.setField('name', 'n1');
             await z.setField('condition', 'off');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'off' }
                          ]}})
             await z.setField('name', 'n3');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             await z.setField('name', 'n2');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             await z.setField('domain', 'd0');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'off' },
                              { domain: 'd1', name: 'n3', condition: 'off' },
                              { domain: 'd1', name: 'n2', condition: 'off' },
                              { domain: 'd0', name: 'n2', condition: 'off' }
                          ]}})
             await z.setField('name', 'n5');
             await z.setField('generator', 'n4');
             await z.setField('generator_name', 'g1');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'n1', condition: 'off' },
                              { domain: 'd1', name: 'n3', condition: 'off' },
                              { domain: 'd1', name: 'n2', condition: 'off' },
                              { domain: 'd0', name: 'n2', condition: 'off' },
                              { domain: 'd0', name: 'n5', condition: 'off', generator_name:'g1',generator:'n4' }
                          ]}})
             z.ao.remove();

             z = await initTest('alert2-manager');
             await sleepMs(100);
             let srez = (await waitSearch()).results;
             jasserteq(srez.length, 5);
             rs = z.ao.shadowRoot.querySelectorAll('div.results > div.anent');
             jasserteq(rs.length, 5);
             jasserteq(rs[0].textContent, 'sensor.alert2generator_g1');
             jasserteq(rs[1].textContent, 'alert2.d0_n2');
             jasserteq(rs[2].textContent, 'alert2.d1_n1');
             jasserteq(rs[3].textContent, 'alert2.d1_n2');
             jasserteq(rs[4].textContent, 'alert2.d1_n3');
             
             // Type a search term
             let txtf = z.ao.shadowRoot.querySelector('ha-textfield');
             jassert(txtf);
             jFireEvent(txtf, 'input', { value: 'z' });
             //txtf.value = 'z';
             await sleepMs(100);
             jasserteq((await waitSearch()).results.length, 0);
             rs = z.ao.shadowRoot.querySelectorAll('div.results > div.anent');
             jasserteq(rs.length, 0);

             jFireEvent(txtf, 'input', { value: 'n' });
             await sleepMs(100);
             jasserteq((await waitSearch()).results.length, 5);
             rs = z.ao.shadowRoot.querySelectorAll('div.results > div.anent');
             jasserteq(rs.length, 5);

             jFireEvent(txtf, 'input', { value: 'n1' });
             await sleepMs(100);
             jasserteq((await waitSearch()).results.length, 1);
             rs = z.ao.shadowRoot.querySelectorAll('div.results > div.anent');
             jasserteq(rs.length, 1);
             jassertObjeq(z.ao.getSearchStatus().rez, { results: [ { id: 'alert2.d1_n1', domain: 'd1', name: 'n1' }]});
             
             jFireEvent(txtf, 'input', { value: 'g1' });
             await sleepMs(100);
             jasserteq((await waitSearch()).results.length, 1);
             rs = z.ao.shadowRoot.querySelectorAll('div.results > div.anent');
             jasserteq(rs.length, 1);
             jassertObjeq(z.ao.getSearchStatus().rez, { results: [ { id: 'sensor.alert2generator_g1', domain: 'alert2generator', name: 'g1' }]});
             z.ao.remove();
         }

         async function doTest5() {
             let tobj = await callApi('POST', 'alert2test/tcheck',
                                      { stage:'reset', yaml: { defaults: { reminder_frequency_mins: 3,
                                                                           annotate_messages: false,
                                      },
                                                               notifier_startup_grace_secs: 3,
                                                               defer_startup_notifications: ['foo']
                                      } } );
             jassertObjeq(tobj, {});

             z = await initTest('alert2-edit-defaults');
             await sleepMs(11);
             z.setField('annotate_messages', 'yes');
             z.setField('notifier', 'happy');
             z.setField('notifier_startup_grace_secs', '5');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button'));
             z.ao.remove();

             // now let's test edit defaults
             z = await initTest('alert2-edit-defaults');
             await sleepMs(100);
             z.checkDefault('notifier', /"persistent_notification"/);
             z.checkDefault('summary_notifier', /empty: false/);
             z.checkDefault('annotate_messages', /empty: false/);
             z.checkDefault('reminder_frequency_mins', /empty: 3/);
             z.checkDefault('throttle_fires_per_mins', /empty: ""/);
             z.checkDefault('skip_internal_errors', /empty: false/);
             z.checkDefault('notifier_startup_grace_secs', /empty: 3/);
             z.checkDefault('defer_startup_notifications', /empty: \["foo"\]/);

             z.ao.remove();
             // now let's test create alert
             z = await initTest('alert2-create');
             await sleepMs(100);
             z.checkDefault('domain', null);
             z.checkDefault('name', null);
             z.checkDefault('friendly_name', null);
             z.checkDefault('condition', null);
             z.checkDefault('condition_on', null);
             z.checkDefault('condition_off', null);
             z.checkDefault('trigger', null);
             z.checkDefault('trigger_on', null);
             z.checkDefault('trigger_off', null);
             z.checkDefault('value', null);
             z.checkDefault('hysteresis', null);
             z.checkDefault('minimum', null);
             z.checkDefault('maximum', null);
             z.checkDefault('delay_on_secs', null);
             z.checkDefault('early_start', null);
             z.checkDefault('manual_off', null);
             z.checkDefault('manual_on', null);
             z.checkDefault('message', null);
             z.checkDefault('done_message', null);
             z.checkDefault('notifier', /empty: "happy"/);
             z.checkDefault('summary_notifier', /empty: false/);
             z.checkDefault('title', null);
             z.checkDefault('display_msg', null);
             z.checkDefault('target', null);
             z.checkDefault('data', null);
             
             z.checkDefault('throttle_fires_per_mins', /empty: ""/);
             z.checkDefault('reminder_frequency_mins', /empty: 3/);
             z.checkDefault('annotate_messages', /empty: "yes"/);
             z.checkDefault('generator', null);
             z.checkDefault('generator_name', null);
             z.ao.remove();
         }
         async function doTest6() {
             let yamlCfg = { alerts: [
                 { domain: 'dd', name: 'nn', condition: 'off' },
                 { domain: 'dd', name: 'nn2', condition: 'off', display_msg: '{{ states("sensor.a") }}' }
             ] };
             let tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.a', state: 'yippy'});
             jassertObjeq(tobj, {});
             
             z = await initTest('alert2-overview');
             const handle_msg = function(ev) {
                 const msg = JSON.parse(ev.data);
                 console.log('yay got ws msg', msg);
             }
             z.ws.addEventListener('message', handle_msg);

             let recent = new Date();
             recent.setSeconds(recent.getSeconds() - 10);
             let recent2 = new Date();
             recent2.setSeconds(recent2.getSeconds() - 12);
             z.ao.hass = {
                 states: { 'binary_sensor.alert2_ha_startup_done' : { attributes: { manifest_version: 'v.a.b.c' } },
                           'alert2.dd_nn': { state: 'on', attributes: { last_on_time: recent.toISOString(),
                                                                        fires_since_last_notify: 0,
                                                                        has_display_msg: false,
                                                                        domain: 'dd', name: 'nn',
                           }, entity_id: 'alert2.dd_nn' },
                           'alert2.dd_nn2': { state: 'on', attributes: { last_on_time: recent2.toISOString(),
                                                                         fires_since_last_notify: 0,
                                                                         has_display_msg: true,
                                                                        domain: 'dd', name: 'nn2',
                           }, entity_id: 'alert2.dd_nn2' },
                 },
                 callApi: z.firstHass.callApi,
                 callWs: z.firstHass.callWs,
                 connection: z.firstHass.connection,
             };
             await sleepMs(2000); // for subscription to happen, and actually for refresh to happen
             console.log('ding');
             //let ac = z.ao.shadowRoot.querySelector('ha-card');
             //jassert(ac);
             let rows = z.ao.shadowRoot.querySelectorAll('hui-alert2-entity-row');
             jasserteq(rows.length, 2);
             jassert(rows[0].shadowRoot.textContent.match(/alert2.dd_nn/));
             jassert(rows[1].shadowRoot.textContent.match(/alert2.dd_nn2/));

             console.log(rows);
             let ad;
             ad = rows[0].shadowRoot.querySelector('div.dispMsg');
             jassert(!ad);
             ad = rows[1].shadowRoot.querySelector('div.dispMsg');
             jassert(ad);
             console.log(ad.textContent);
             jassert(ad.textContent.match(/yippy/));
             
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.a', state: 'yi<b>pp</b>y2'});
             jassertObjeq(tobj, {});
             await sleepMs(100);
             ad = rows[0].shadowRoot.querySelector('div.dispMsg');
             jassert(!ad);
             ad = rows[1].shadowRoot.querySelector('div.dispMsg');
             jassert(ad);
             console.log(ad.textContent);
             jassert(ad.textContent.match(/yi<b>pp<.b>y2/));

             // Test harness doesn't support reload
             //await z.callWs({ type: "execute_script", sequence: [ { service: 'alert2.reload', data: {}, }], });

             // Check to see if we track display_msg even if reload happens
             //
             yamlCfg.alerts[1].display_msg = '{{ states("sensor.b") }}';
             tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.a', state: 'yippy3'});
             jassertObjeq(tobj, {});
             await sleepMs(100);
             ad = rows[0].shadowRoot.querySelector('div.dispMsg');
             jassert(!ad);
             ad = rows[1].shadowRoot.querySelector('div.dispMsg');
             jassert(ad);
             console.log(ad.textContent);
             jassert(ad.textContent.match(/unknown/)); // since sensor.b doesn't exist
             
             if (0) {
                 console.log('long sleep............');
                 while (true) {
                     //console.log(z.ws.readyState);
                     await sleepMs(3000);
                 }
             }

             z.ao.remove();
         }
         async function doTest7() {
             // Make sure null for notifier and display_msg get saved correctly
             z = await initTest('alert2-create');
             await sleepMs(10); // seems to help dom get itself sorted out
             await z.setField('domain', 'd1');
             await z.setField('name', 'ny');
             await z.setField('condition', 'off');
             await z.setField('notifier', 'null');
             await z.setField('display_msg', 'null');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             jassertObjeq(await callApi('POST', 'alert2test/tcheck', { stage:'getUiData'} ),
                          {config:{ defaults: {}, alerts: [
                              { domain: 'd1', name: 'ny', condition: 'off', notifier: 'null', display_msg: 'null' }
                          ]}})
             z.ao.remove();
         }
         async function doTest8() {
             let z = await initTest('alert2-overview');
             let yamlCfg = { alerts: [
                 { domain: 'dd', name: 'foo', condition: 'off', display_msg: '{{ states("sensor.foo") }}' },
                 { domain: 'dd', name: 'bar', condition: 'off', display_msg: '{{ states("sensor.bar") }}' }
             ] };
             let tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.foo', state: 'sfoo'} );
             jassertObjeq(tobj, {});
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.bar', state: 'sbar'} );
             jassertObjeq(tobj, {});

             let alert2Tools = customElements.get('alert2-tools');
             let hass = { states: {
                 'alert2.dd_foo': { attributes: { domain: 'dd', name: 'foo', has_display_msg: false } },
                 'alert2.dd_bar': { attributes: { domain: 'dd', name: 'bar', has_display_msg: true } } },
                          callApi: z.firstHass.callApi,
                          callWs: z.firstHass.callWs,
                          connection: z.firstHass.connection
             };
             
             let dm = new alert2Tools.DisplayValMonitor();
             dm.updateHass(hass);
             let cb1Calls = [];
             let cb1 = (msg, has_msg) => { cb1Calls.push({msg, has_msg}); };
             let cb2Calls = [];
             let cb2 = (msg, has_msg) => { cb2Calls.push({msg, has_msg}); };

             dm.addChangeCb('alert2.dd_foo', cb1);
             tobj = cb1Calls.pop();
             jassertObjeq(tobj, {msg: null, has_msg: false});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 0);

             // Initial result is null, cuz hasn't had time to fetch
             dm.addChangeCb('alert2.dd_bar', cb2);
             tobj = cb2Calls.pop();
             jassertObjeq(tobj, {msg: null, has_msg: true});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 0);

             // First fetch of display_msg
             await sleepMs(100);
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.pop();
             jassertObjeq(tobj, {msg: 'sbar', has_msg: true});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 0);

             // Update template val, should update in the monitor
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.bar', state: 'sbar2'} );
             jassertObjeq(tobj, {});
             await sleepMs(100);
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.pop();
             jassertObjeq(tobj, {msg: 'sbar2', has_msg: true});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 0);

             // Reloading config shouldn't change vals
             // only bar refreshes val cuz foo has has_display_msg set to false
             tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             await sleepMs(100);
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.pop();
             jassertObjeq(tobj, {msg: 'sbar2', has_msg: true});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 0);
             
             // set has_display_msg false for bar.
             hass = { states: {
                 'alert2.dd_foo': { attributes: { domain: 'dd', name: 'foo', has_display_msg: false } },
                 'alert2.dd_bar': { attributes: { domain: 'dd', name: 'bar', has_display_msg: false } } },
                      callApi: z.firstHass.callApi,
                      callWs: z.firstHass.callWs,
                      connection: z.firstHass.connection
             };
             dm.updateHass(hass);
             await sleepMs(100);
             jasserteq(cb1Calls.length, 1);
             tobj = cb1Calls.pop();
             jassertObjeq(tobj, {msg: null, has_msg: false});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.pop();
             jassertObjeq(tobj, {msg: 'sbar2', has_msg: false});
             jasserteq(cb2Calls.length, 0);

             // now set has_display_msg true for foo.
             hass = { states: {
                 'alert2.dd_foo': { attributes: { domain: 'dd', name: 'foo', has_display_msg: true } },
                 'alert2.dd_bar': { attributes: { domain: 'dd', name: 'bar', has_display_msg: false } } },
                      callApi: z.firstHass.callApi,
                      callWs: z.firstHass.callWs,
                      connection: z.firstHass.connection
             };
             dm.updateHass(hass);
             await sleepMs(100);
             jasserteq(cb1Calls.length, 2);
             tobj = cb1Calls.shift();
             // First cb to convey has_display_msg has changed to true
             jassertObjeq(tobj, {msg: null, has_msg: true});
             tobj = cb1Calls.shift();
             // One cb cuz server sends initial value of sfoo
             jassertObjeq(tobj, {msg: 'sfoo', has_msg: true});
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.pop();
             jassertObjeq(tobj, {msg: null, has_msg: false});
             jasserteq(cb2Calls.length, 0);

             // Now switch cb2 from bar to foo
             dm.removeChangeCb('alert2.dd_bar', cb2);
             await sleepMs(50);
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 0);
             dm.addChangeCb('alert2.dd_foo', cb2);
             await sleepMs(50);
             jasserteq(cb1Calls.length, 0);
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.shift();
             jassertObjeq(tobj, {msg: 'sfoo', has_msg: true});
             jasserteq(cb2Calls.length, 0);

             // update foo should update both cbs
             tobj = await callApi('POST', 'alert2test/tcheck',
                                  { stage:'setEnt', entity_id: 'sensor.foo', state: 'sfoo2'} );
             jassertObjeq(tobj, {});
             await sleepMs(100);
             jasserteq(cb1Calls.length, 1);
             tobj = cb1Calls.shift();
             jassertObjeq(tobj, {msg: 'sfoo2', has_msg: true});
             jasserteq(cb2Calls.length, 1);
             tobj = cb2Calls.shift();
             jassertObjeq(tobj, {msg: 'sfoo2', has_msg: true});

             z.ao.remove();
         }
         async function doTest9() {
             let z = await initTest('alert2-create');
             let yamlCfg = { alerts: [
                 { domain: 'd', name: 'n1', condition: 'off' },
                 { domain: 'd', name: 'n2', condition: 'off', supersedes: [ { domain: 'd', name: 'n1' } ] }
             ] };
             let tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             
             let alert2Tools = customElements.get('alert2-tools');
             let dataReadyCbCount = 0;
             let dataReadyCbReloadCount = 0;
             let dc = new alert2Tools.DisplayConfigMonitor((isReload) => { if (isReload) { dataReadyCbReloadCount += 1; } else { dataReadyCbCount += 1; }});
             jasserteq(dataReadyCbCount, 0);

             // No display should be fine
             dc.addConfigInfo([]);
             jasserteq(dataReadyCbCount, 0);

             // No hass yet
             dinfos = [ { entityName: 'alert2.d_n1' } ];
             dc.addConfigInfo(dinfos);
             await sleepMs(10);
             jasserteq(dataReadyCbCount, 0);
             jasserteq(dataReadyCbReloadCount, 0);

             dinfos = [];
             dc.addConfigInfo(dinfos);
             await sleepMs(200);
             jasserteq(dataReadyCbCount, 0);
             jasserteq(dataReadyCbReloadCount, 0);
             
             // hass, but still in startup
             let hass = { states: {
                 'alert2.d_n1': { attributes: { domain: 'd', name: 'n1' } },
                 'alert2.d_n2': { attributes: { domain: 'd', name: 'n2' } },
                 'binary_sensor.alert2_ha_startup_done': { state: 'off' },
             },
                          callApi: z.firstHass.callApi,
                          callWs: z.firstHass.callWs,
                          connection: z.firstHass.connection
             };
             dc.updateHass(hass);
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 0);
             jasserteq(dataReadyCbReloadCount, 0);
             // startup done
             hass = { states: {
                 'alert2.d_n1': { attributes: { domain: 'd', name: 'n1' } },
                 'alert2.d_n2': { attributes: { domain: 'd', name: 'n2' } },
                 'binary_sensor.alert2_ha_startup_done': { state: 'on' },
             },
                          callApi: z.firstHass.callApi,
                          callWs: z.firstHass.callWs,
                          connection: z.firstHass.connection
             };
             dc.updateHass(hass);
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 0);
             jasserteq(dataReadyCbReloadCount, 1);
             
             dinfos = [ { entityName: 'alert2.d_n1' } ];
             dc.addConfigInfo(dinfos);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: null } ] );
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 1);
             jasserteq(dataReadyCbReloadCount, 1);
             dc.addConfigInfo(dinfos);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: { supersededBySet: new Set([ 'alert2.d_n2']), priority: 'low' } } ] );

             // Should be cached now, so response should be immediate
             dinfos = [ { entityName: 'alert2.d_n1' } ];
             dc.addConfigInfo(dinfos);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: { supersededBySet: new Set([ 'alert2.d_n2']), priority: 'low' } } ] );
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 1);

             // Reload (because we change the binary_sensor) should clear the cache and refetch everything.
             console.log('\ntest\n');
             hass = { states: {
                 'alert2.d_n1': { attributes: { domain: 'd', name: 'n1' } },
                 'alert2.d_n2': { attributes: { domain: 'd', name: 'n2' } },
                 'binary_sensor.alert2_ha_startup_done': { state: 'on' },
             },
                          callApi: z.firstHass.callApi,
                          callWs: z.firstHass.callWs,
                          connection: z.firstHass.connection
             };
             dc.updateHass(hass);
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 1);
             jasserteq(dataReadyCbReloadCount, 2);

             // addConfigInfo again should trigger a new fetch
             dinfos = [ { entityName: 'alert2.d_n1' } ];
             dc.addConfigInfo(dinfos);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: null } ] );
             jasserteq(dataReadyCbCount, 1);
             jasserteq(dataReadyCbReloadCount, 2);
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 2);
             jasserteq(dataReadyCbReloadCount, 2);
             
             // Now should be immediate
             dinfos = [ { entityName: 'alert2.d_n1' } ];
             dc.addConfigInfo(dinfos);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: { supersededBySet: new Set([ 'alert2.d_n2']), priority: 'low' } } ] );
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 2);
             jasserteq(dataReadyCbReloadCount, 2);

             // Fetch of n2 is new so won't be immediate
             dinfos = [ { entityName: 'alert2.d_n1' }, { entityName:'alert2.d_n2'} ];
             dc.addConfigInfo(dinfos);
             jasserteq(dataReadyCbCount, 2);
             jasserteq(dataReadyCbReloadCount, 2);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: { supersededBySet: new Set([ 'alert2.d_n2']), priority: 'low' } },
                                    { entityName: 'alert2.d_n2', configInfo: null }
             ] );
             //    fetch happens, we get callback, and then next request has immediate results
             await sleepMs(100);
             jassertObjeq(dinfos, [ { entityName: 'alert2.d_n1', configInfo: { supersededBySet: new Set([ 'alert2.d_n2']), priority: 'low' } },
                                    { entityName: 'alert2.d_n2', configInfo: null }
             ] );
             jasserteq(dataReadyCbCount, 3);
             jasserteq(dataReadyCbReloadCount, 2);
             dc.addConfigInfo(dinfos);
             jassertObjeq(dinfos, [
                 { entityName: 'alert2.d_n1', configInfo: { supersededBySet: new Set([ 'alert2.d_n2']), priority: 'low' } },
                 { entityName: 'alert2.d_n2', configInfo: { supersededBySet: new Set([ ]), priority: 'low' } },
             ] );
             await sleepMs(100);
             jasserteq(dataReadyCbCount, 3);
             jasserteq(dataReadyCbReloadCount, 2);

             // If a new entity is created, that results in update, which clears cache, does a refresh and
             // then update
             await z.setField('domain', 'd');
             await z.setField('name', 'n3');
             await z.setField('condition', 'off');
             await clickWait(z.ao.shadowRoot.querySelector('ha-progress-button.createB'));
             z.checkErr(null);
             await sleepMs(200);
             jasserteq(dataReadyCbCount, 3);
             jasserteq(dataReadyCbReloadCount, 3);

             z.ao.remove();
         }
         async function doTest10() {
             let z = await initTest('alert2-overview');
             let yamlCfg = { alerts: [
                 { domain: 'd', name: 'n1', condition: 'off' },
                 { domain: 'd', name: 'n2', condition: 'off', supersedes: [ { domain: 'd', name: 'n1' } ] },
                 { domain: 'd', name: 'n3', condition: 'off', supersedes: [ { domain: 'd', name: 'n1' } ] },
                 { domain: 'd', name: 'n4', condition: 'off', supersedes: [ { domain: 'd', name: 'n2' },{ domain:'d', name: 'n3'} ] },
                 { domain: 'd', name: 'n5', condition: 'off', priority: 'medium' },
             ] };
             let tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             

             // n5 is higher priority so should be above if on
             await createExperiment(z, [ createState('n1', 1000, 7000, 20000),
                                      createState('n5', 5000, 7000, 20000) ],
                                    ['n5', 'n1']);
             let tEls = z.ao.shadowRoot.querySelectorAll('hui-alert2-entity-row');
             let stateBadge = tEls[0].shadowRoot.querySelector('state-badge');
             jassert(stateBadge.classList.contains('mediumpri'));
             stateBadge = tEls[1].shadowRoot.querySelector('state-badge');
             jassert(stateBadge.classList.contains('lowpri'));
             

             
             // n2 supersedes n1 so should be below
             await createExperiment(z, [ createState('n1', 1000, 7000, 20000),
                                      createState('n2', 2000, 7000, 20000) ],
                                    ['n2', 'n1']);
             // same with n3, even with "on" time ordering reversed
             await createExperiment(z, [ createState('n1', 2000, 7000, 20000),
                                      createState('n3', 1000, 7000, 20000) ],
                                    ['n3', 'n1']);
             // n2 and n3 don't supersede each other, so should be time ordered.
             await createExperiment(z, [ createState('n2', 2000, 7000, 20000),
                                      createState('n3', 1000, 7000, 20000) ],
                                    ['n3', 'n2']);
             await createExperiment(z, [ createState('n2', 1000, 7000, 20000),
                                      createState('n3', 2000, 7000, 20000) ],
                                    ['n2', 'n3']);

             // supersedes works even if separated by one
             await createExperiment(z, [ createState('n1', 1000, 7000, 20000),
                                      createState('n4', 2000, 7000, 20000) ],
                                    ['n4', 'n1']);
             await createExperiment(z, [ createState('n1', 2000, 7000, 20000),
                                      createState('n4', 1000, 7000, 20000) ],
                                    ['n4', 'n1']);

             // supersedes doesn't apply to off alerts.  supersedes alert is off.
             await createExperiment(z, [ createState('n1', 9000, 10000, 20000),
                                      createState('n2', 8000, 7000, 20000) ],
                                    ['n1', 'n2']);
             // superseded alert is off
             await createExperiment(z, [ createState('n1', 8000, 7000, 20000),
                                      createState('n2', 9000, 10000, 20000) ],
                                    ['n2', 'n1']);

             await createExperiment(z, [ createState('n4', 1000, 10000, 20000),
                                      createState('n2', 3000, 10000, 20000),
                                      createState('n1', 2000, 10000, 20000) ],
                                    ['n4', 'n2', 'n1']);

             // n2 and n3 superseded n1.  n2 and n3 should be time ordered
             await createExperiment(z, [ createState('n1', 1000, 10000, 20000),
                                      createState('n2', 3000, 10000, 20000),
                                      createState('n3', 2000, 10000, 20000) ],
                                    ['n3', 'n2', 'n1']);
             await createExperiment(z, [ createState('n1', 1000, 10000, 20000),
                                      createState('n2', 2000, 10000, 20000),
                                      createState('n3', 3000, 10000, 20000) ],
                                    ['n2', 'n3', 'n1']);

             // Supersedes applies to ack'd alerts
             await createExperiment(z, [ createState('n1', 3000, 7000, 20000),
                                      createState('n2', 5000, 7000, 4000) ],
                                    ['n2', 'n1'], nBelow=2);
             await createExperiment(z, [ createState('n1', 3000, 7000, 2000),
                                      createState('n2', 5000, 7000, 20000) ],
                                    ['n2', 'n1'], nBelow=0);
             await createExperiment(z, [ createState('n1', 3000, 7000, 20000),
                                      createState('n2', 5000, 7000, 20000) ],
                                    ['n2', 'n1']);
             
             z.ao.remove();
         }
         async function doTestConfig() {
             let z = await initTest('alert2-overview', {}, null);
             let yamlCfg = { alerts: [
             ] };
             let tobj = await callApi('POST', 'alert2test/tcheck', { stage:'reset', yaml: yamlCfg });
             jassertObjeq(tobj, {});
             
             const hrAgoMs = 60 * 60 * 1000;
             // n2 off and unacked, but outside interval
             await createExperiment(z, [ createState('n1', 4*hrAgoMs + 12000, 4*hrAgoMs - 10000, 4*hrAgoMs + 20000),
                                         createState('n2', 4*hrAgoMs + 12000, 4*hrAgoMs + 11000, 4*hrAgoMs + 20000) ],
                                    ['n1']);
             jasserteq(z.ao.shadowRoot.querySelector('h1').textContent.trim(), 'Alerts');

             z.ao.remove();
             z = await initTest('alert2-overview', {}, { title: 'yay', include_old_unacked: 'true' });
             // n2 off and unacked, but outside interval but config set to include
             await createExperiment(z, [ createState('n1', 4*hrAgoMs + 12000, 4*hrAgoMs - 10000, 4*hrAgoMs + 20000),
                                         createState('n2', 4*hrAgoMs + 12000, 4*hrAgoMs + 11000, 4*hrAgoMs + 20000) ],
                                    ['n1', 'n2']);
             jasserteq(z.ao.shadowRoot.querySelector('h1').textContent.trim(), 'yay');

             z.ao.remove();
             z = await initTest('alert2-overview', {}, { include_old_unacked: 'true', filter_entity_id: '*n2' });
             // Try filter
             await createExperiment(z, [ createState('n1', 4*hrAgoMs + 12000, 4*hrAgoMs - 10000, 4*hrAgoMs + 20000),
                                         createState('n2', 4*hrAgoMs + 12000, 4*hrAgoMs + 11000, 4*hrAgoMs + 20000) ],
                                    ['n2']);

             z.ao.remove();
             z = await initTest('alert2-overview', {}, { include_old_unacked: 'true', filter_entity_id: '/n1/' });
             // Try filter with regex
             await createExperiment(z, [ createState('n1', 4*hrAgoMs + 12000, 4*hrAgoMs - 10000, 4*hrAgoMs + 20000),
                                         createState('n2', 4*hrAgoMs + 12000, 4*hrAgoMs + 11000, 4*hrAgoMs + 20000) ],
                                    ['n1']);
         }
        </script>
    </head>
    <body>
        <h2 id="testStatus">Test: Loading libraries...</h2>
        <div id="testDiv" style="width: 100%; max-width: 30em;"></div>
    </body>
</html>
